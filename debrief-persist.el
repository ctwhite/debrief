;;; debrief-persist.el --- Debrief persistence functions -*- lexical-binding: t; -*-
;;
;;; Commentary:
;;
;; This module handles the persistence of the Debrief debugging framework's
;; configuration state across Emacs sessions. It allows users to save their
;; current debugging setup and restore it later, ensuring a consistent
;; debugging environment.
;;
;; Core Functionality:
;;
;; - `debrief/save-state`: Writes the current global debug settings (like
;;   `debrief-debug-enabled`, logging configurations) and all registered
;;   debug target configurations to a specified file (`debrief-persist-file`).
;;   It carefully excludes runtime-specific data (e.g., internal advice
;;   lambdas, temporary flags) that should not be persisted.
;;
;; - `debrief/load-state`: Reads the saved configuration from the persistence
;;   file. It first clears any existing in-memory Debrief configurations, then
;;   evaluates the contents of the file to restore global settings and
;;   re-registers each debug target. This effectively restores the previous
;;   debugging environment.
;;
;; - `debrief/reset-all`: Provides a way to clear all current Debrief
;;   configurations, remove the persistence file, and revert Debrief to its
;;   default, unconfigured state. This is useful for starting fresh or if the
;;   persisted state is suspected to be problematic.
;;
;; This module relies on `debrief-core.el` for accessing core data structures
;; (like `debrief--debug-config`) and logging utilities.

;;; Code:

(require 'cl-lib)
(require 'dash)          ; For utility functions like --each, --reduce-from
(require 'debrief-core)  ; For core variables and functions
(require 'debrief-log)   ; For logging utilities

;; Declare functions used from other Debrief modules to satisfy byte-compiler.
(declare-function debrief/list-registered-targets "debrief-ui" ())

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                         Persistence Functions                              ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defvar debrief--loaded-configs nil
  "Temporary variable to hold configurations when `debrief-persist-file` is loaded.
This variable is populated by `load-file` when the persistence file is evaluated.
`debrief/load-state` then processes these configurations to re-register targets.
It is cleared after loading to prevent unintended side effects or re-use.")

;;;###autoload
(defun debrief/save-state ()
  "Persist Debrief's current debug state and configurations.
This includes global settings like `debrief-debug-enabled`, logging options,
and the configurations of all registered debug targets.
The state is saved to the file specified by `debrief-persist-file`.
Runtime-specific data (e.g., internal advice functions, temporary flags)
are excluded from persistence.
Return:
  nil. Side effect is writing to the persistence file."
  (interactive)
  (debrief--log :info nil "Saving Debrief configuration to %s..." debrief-persist-file)
  (condition-case err
      (with-temp-file debrief-persist-file
        ;; Header for the persistence file
        (insert ";;; Debrief Persistence File - Automatically Generated\n")
        (insert ";;; Do not edit this file manually unless you know what you are doing.\n\n")

        ;; Save global Debrief settings.
        (insert ";; Global Debrief Settings\n")
        (insert (format "(setq debrief-debug-enabled %S)\n" debrief-debug-enabled))
        (insert (format "(setq debrief-log-destination %S)\n" debrief-log-destination))
        (insert (format "(setq debrief-log-dedicated-buffer-name %S)\n"
                        debrief-log-dedicated-buffer-name))
        (insert (format "(setq debrief-log-file-path %S)\n" debrief-log-file-path))
        (insert (format "(setq debrief-log-level-threshold %S)\n"
                        debrief-log-level-threshold))
        (insert (format "(setq debrief-hook-monitor-enabled %S)\n"
                        debrief-hook-monitor-enabled))
        ;; Persist the list of hooks that were actively being monitored.
        ;; On load, `debrief--ensure-global-hook-advice` will use this.
        (insert (format "(setq debrief--active-monitored-hooks %S)\n\n"
                        debrief--active-monitored-hooks))

        ;; Persist cleaned debug target configurations.
        (insert ";; Registered Debug Target Configurations\n")
        (insert "(setq debrief--loaded-configs\n  '(\n")
        (ht-map
         (lambda (target config)
           (when (listp config) ; Ensure config is a plist
             ;; Keys to exclude: these are runtime-generated or internal state.
             (let* ((keys-to-exclude '(:watcher-fn :break-on-change-active :wrapper
                                       :name ; Advice name is regenerated
                                       :currently-active ; Runtime state
                                       ;; Filters are functions, may not be serializable
                                       ;; or may be better to re-generate if default.
                                       ;; User-provided :arg-filter/:return-filter are persisted.
                                       ;; :fn (custom advice) is also persisted.
                                       :pending-load
                                       :active-advice-name))
                    ;; Rebuild the config plist, excluding specified keys.
                    (rebuilt-config
                     (--reduce-from
                      (if (memq (car it) keys-to-exclude) ; If key is in exclude list
                          acc                             ; Skip it
                        (plist-put acc (car it) (cadr it))) ; Else, add to new plist
                      nil ; Initial accumulator for rebuilt plist
                      (-partition 2 config)))) ; Process original config as (key val) pairs

               (debrief--log :debug target "Persisting cleaned config for %S: %S"
                             target rebuilt-config)
               ;; Write the rebuilt plist to the file. `prin1-to-string` ensures
               ;; it's readable Lisp data.
               (insert "    " (prin1-to-string rebuilt-config) "\n"))))
         debrief--debug-config)
        (insert "  ))\n") ; End of debrief--loaded-configs list
        (debrief--log :info nil "Debrief configuration saved successfully to %s."
                      debrief-persist-file))
    (error
     (debrief--log :error nil "Failed to save Debrief configuration to %s: %S"
                   debrief-persist-file err)
     (message "Debrief: Error saving state to %s. See *Messages*."
              debrief-persist-file)))
  nil)

;;;###autoload
(defun debrief/load-state ()
  "Restore Debrief's configuration from `debrief-persist-file`.
This function clears the current in-memory Debrief state, then loads and
evaluates the persistence file. It re-registers all debug targets found in
the file and re-applies the global debug settings.
If the persistence file does not exist, it logs an informational message
and does nothing further.
Return:
  nil. Side effect is modifying Debrief's internal state and applying settings."
  (interactive)
  (if (not (file-exists-p debrief-persist-file))
      (debrief--log :info nil
                    "No Debrief persistence file found at %s. Skipping load."
                    debrief-persist-file)
    (debrief--log :info nil "Loading Debrief configuration from %s..."
                  debrief-persist-file)
    (condition-case err
        (progn
          ;; Clear current in-memory state before loading.
          (ht-clear! debrief--debug-config)
          (ht-clear! debrief--debug-groups)
          (clrhash debrief--original-values) ; `clrhash` is for hash-table.el
          (setq debrief--active-monitored-hooks nil)
          (setq debrief--global-hook-monitor-advice-active-p nil)
          ;; The `debrief--loaded-configs` var will be set by `load-file`.
          (setq debrief--loaded-configs nil)

          ;; Evaluate the saved file. This will set global variables like
          ;; `debrief-debug-enabled` and populate `debrief--loaded-configs`.
          (load-file debrief-persist-file)

          ;; Re-register debug targets from the loaded configurations.
          (when debrief--loaded-configs
            (debrief--log :debug nil "Registering %d debug targets from saved state."
                          (length debrief--loaded-configs))
            (dolist (entry-plist debrief--loaded-configs)
              (if (plistp entry-plist) ; Ensure entry is a valid plist
                  ;; Sanitize again, as persisted format might differ slightly or
                  ;; to catch any manual edits to persist file.
                  (let ((sanitized-entry (debrief--sanitize-entry-plist entry-plist)))
                    (when-let ((target (plist-get sanitized-entry :target)))
                      ;; Register without saving state again during this batch load.
                      (debrief--register-debug-target target sanitized-entry nil)))
                (debrief--log :error nil
                              "Corrupted entry in loaded configs: Expected plist, got %S. Skipping."
                              entry-plist)))
            ;; Clear the temporary variable after processing.
            (setq debrief--loaded-configs nil))

          ;; Re-apply global debug state and refresh all targets based on loaded settings.
          ;; `debrief-update-debug-vars` will handle applying configs to all targets.
          (debrief-update-debug-vars debrief-debug-enabled)
          (debrief--log :info nil "Debrief configuration loaded successfully from %s."
                        debrief-persist-file))
      (error
       (debrief--log :error nil "Failed to load Debrief configuration from %s: %S"
                     debrief-persist-file err)
       (message "Debrief: Error loading state from %s. See *Messages*."
                debrief-persist-file))))
  nil)

;;;###autoload
(defun debrief/reset-all ()
  "Reset all Debrief configurations to their default states.
This function performs a comprehensive reset:
- Deactivates all currently active debug targets (removing advice, watchers).
- Clears all internal Debrief data structures (configurations, groups, etc.).
- Resets Debrief-specific custom variables to their `defcustom` default values.
- Re-initializes targets based on the default `debrief-debug-vars`.
- Deletes the Debrief persistence file (`debrief-persist-file`), if it exists.
This is useful for starting with a clean Debrief slate or recovering from
a potentially corrupted or problematic configuration.
A restart of Emacs might be advisable after a full reset if unexpected
behavior persists, though Debrief attempts to clean up thoroughly.
Return:
  nil. Extensive side effects on Debrief's state and the persistence file."
  (interactive)
  (debrief--log :warn nil "Resetting all Debrief configurations to defaults...")

  ;; 1. Deactivate all currently active targets to ensure proper cleanup
  ;;    (e.g., advice removed, watchers detached).
  ;;    Iterate over a copy of keys as deactivation might modify `debrief--debug-config`.
  (let ((current-targets (ht-keys debrief--debug-config)))
    (--each current-targets
      (lambda (target-sym)
        (when-let ((entry-plist (ht-get debrief--debug-config target-sym)))
          ;; To deactivate, we effectively tell `debrief-apply-entry-config`
          ;; that the entry is no longer active by simulating a disabled state.
          ;; The actual `debrief--is-entry-active-p` will use the new global
          ;; `debrief-debug-enabled` (which will be set to nil soon).
          (let ((debrief-debug-enabled nil)) ; Temporarily disable for this call
            (debrief-apply-entry-config entry-plist))))))

  ;; 2. Clear internal Debrief data structures.
  (ht-clear! debrief--debug-config)
  (ht-clear! debrief--debug-groups)
  (clrhash debrief--original-values) ; `clrhash` for hash-table.el compatibility
  (setq debrief--active-monitored-hooks nil)
  (setq debrief--global-hook-monitor-advice-active-p nil)
  ;; Ensure global hook advice is physically removed if it was active.
  (debrief--ensure-global-hook-advice nil)

  ;; 3. Reset Debrief's custom variables to their `defcustom` default values.
  ;;    The `nil t` arguments to `custom-set-variables` achieve this.
  (custom-set-variables
   '(debrief-debug-enabled nil nil t) ; Reset to nil, mark as default
   '(debrief-log-destination :messages nil t)
   '(debrief-log-dedicated-buffer-name "*Debrief Log*" nil t)
   '(debrief-log-file-path (locate-user-emacs-file "debrief-log.log") nil t)
   '(debrief-log-level-threshold 'debug nil t)
   '(debrief-hook-monitor-enabled t nil t))
  ;; After resetting, explicitly call the setter for debrief-debug-enabled
  ;; to ensure its logic (like calling debrief-update-debug-vars) runs.
  (setq debrief-debug-enabled nil)

  ;; 4. Re-initialize targets from the default `debrief-debug-vars` (from `debrief-core.el`).
  ;;    This will populate `debrief--debug-config` with defaults, but they will be
  ;;    inactive due to `debrief-debug-enabled` being nil.
  (debrief--initialize-targets-from-custom-vars)

  ;; 5. Delete the persistence file if it exists.
  (when (file-exists-p debrief-persist-file)
    (condition-case err
        (delete-file debrief-persist-file)
      (error (debrief--log :error nil "Failed to delete persistence file %s: %S"
                           debrief-persist-file err)))
    (debrief--log :info nil "Deleted Debrief persistence file: %s"
                  debrief-persist-file))

  (debrief--log :info nil
                "Debrief configurations reset to defaults. Restart Emacs if issues persist.")
  (message "Debrief configurations reset to defaults. Restart Emacs if issues persist."))

(provide 'debrief-persist)
;;; debrief-persist.el ends here