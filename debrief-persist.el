;;; debrief-persist.el --- Debrief persistence functions -*- lexical-binding: t; -*-
;;
;; Copyright (C) 2025 Your Name
;;
;; This file is not part of GNU Emacs.

;;; Commentary:
;;
;; This module handles the persistence of the Debrief debugging framework's
;; configuration state. It provides functions to:
;;
;; - **Save State**: Write the current global debug settings, logging
;;   configurations, and all registered debug targets to a file
;;   (`debrief-persist-file`). This allows the debug setup to be
;;   restored across Emacs sessions.
;; - **Load State**: Read the saved configuration from the persistence file
;;   and re-apply it, effectively restoring the previous debugging environment.
;;   Loaded state augments or overrides configurations from `debrief-debug-vars`.
;; - **Reset All**: Clear all current configurations, remove the persistence
;;   file, and revert Debrief to its default, unconfigured state.
;;
;; This module declares variables (like `debrief-persist-file`,
;; `debrief--debug-config`, etc.) that are defined in `debrief-core.el` or
;; `debrief-log.el` to manage dependencies.

;;; Code:

(require 'cl-lib)
(require 'dash)       ; For utility functions like --each, --reduce-from
;; (require 'debrief-core) ; Removed to break potential circular dependencies

;; Declare variables and functions from other Debrief modules.
;; These are defined in debrief-core.el or debrief-log.el.
(defvar debrief-persist-file)
(defvar debrief-debug-enabled)
(defvar debrief-log-destination)
(defvar debrief-log-dedicated-buffer-name)
(defvar debrief-log-file-path)
(defvar debrief-log-level-threshold)
(defvar debrief-hook-monitor-enabled)
(defvar debrief--active-monitored-hooks)
(defvar debrief--debug-config)
(defvar debrief--debug-groups)
(defvar debrief--original-values)
(defvar debrief--global-hook-monitor-advice-active-p)
(defvar debrief--loaded-configs) ; Used temporarily during load

(declare-function debrief--log "debrief-log" (level target-symbol format-string &rest args))
(declare-function debrief-update-debug-vars "debrief-core" (enabled))
(declare-function debrief--sanitize-entry-plist "debrief-core" (raw-plist))
(declare-function debrief--register-debug-target "debrief-core"
                  (target-symbol config-plist &optional save-state-p))
(declare-function debrief--initialize-targets-from-custom-vars "debrief-core" ())
(declare-function debrief/list-registered-targets "debrief-ui" ())
(declare-function debrief-apply-entry-config "debrief-core" (config-entry))
(declare-function debrief--ensure-global-hook-advice "debrief-core" (activate-p))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                         Persistence Functions                              ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;###autoload
(defun debrief/save-state ()
  "Persist Debrief's current debug state and configurations.
This includes global settings like `debrief-debug-enabled`, logging options,
and the configurations of all registered debug targets.
The state is saved to the file specified by `debrief-persist-file`.
Runtime-specific data (e.g., internal advice functions, temporary flags)
are excluded from persistence.
Return:
  nil. Side effect is writing to the persistence file."
  (interactive)
  (debrief--log :info nil "Saving Debrief configuration to %s..." debrief-persist-file)
  (condition-case err
      (with-temp-file debrief-persist-file
        ;; Header for the persistence file
        (insert ";;; Debrief Persistence File - Automatically Generated\n")
        (insert ";;; Do not edit this file manually unless you know what you are doing.\n\n")

        ;; Save global Debrief settings.
        (insert ";; Global Debrief Settings\n")
        (insert (format "(setq debrief-log-destination %S)\n" debrief-log-destination))
        (insert (format "(setq debrief-log-dedicated-buffer-name %S)\n"
                        debrief-log-dedicated-buffer-name))
        (insert (format "(setq debrief-log-file-path %S)\n" debrief-log-file-path))
        (insert (format "(setq debrief-log-level-threshold %S)\n"
                        debrief-log-level-threshold))
        (insert (format "(setq debrief-hook-monitor-enabled %S)\n"
                        debrief-hook-monitor-enabled))
        ;; Persist the list of actively monitored hooks *as a quoted list*.
        (insert (format "(setq debrief--active-monitored-hooks '%S)\n\n" ; Corrected
                        debrief--active-monitored-hooks))

        ;; Persist cleaned debug target configurations.
        (insert ";; Registered Debug Target Configurations\n")
        (insert "(setq debrief--loaded-configs\n  '(\n")
        (ht-map
         (lambda (target config)
           (when (listp config) ; Ensure config is a plist
             ;; Keys to exclude: these are runtime-generated or internal state.
             (let* ((keys-to-exclude '(:watcher-fn :break-on-change-active :wrapper
                                       :name ; Advice name is regenerated
                                       :currently-active ; Runtime state
                                       ;; Filters are functions, may not be serializable
                                       ;; or may be better to re-generate if default.
                                       ;; User-provided :arg-filter/:return-filter are persisted.
                                       ;; :fn (custom advice) is also persisted.
                                       :pending-load
                                       :active-advice-name))
                    ;; Rebuild the config plist, excluding specified keys.
                    (rebuilt-config
                     (--reduce-from
                      (if (memq (car it) keys-to-exclude) ; If key is in exclude list
                          acc                             ; Skip it
                        (plist-put acc (car it) (cadr it))) ; Else, add to new plist
                      nil ; Initial accumulator for rebuilt plist
                      (-partition 2 config)))) ; Process original config as (key val) pairs

               (debrief--log :debug target "Persisting cleaned config for %S: %S"
                             target rebuilt-config)
               ;; Write the rebuilt plist to the file. `prin1-to-string` ensures
               ;; it's readable Lisp data.
               (insert "    " (prin1-to-string rebuilt-config) "\n"))))
         debrief--debug-config)
        (insert "  ))\n") ; End of debrief--loaded-configs list
        (debrief--log :info nil "Debrief configuration saved successfully to %s."
                      debrief-persist-file))
    (error
     (debrief--log :error nil "Failed to save Debrief configuration to %s: %S"
                   debrief-persist-file err)
     (message "Debrief: Error saving state to %s. See *Messages*."
              debrief-persist-file)))
  nil)

;;;###autoload
(defun debrief/load-state ()
  "Restore Debrief's configuration from `debrief-persist-file`.
This function loads and evaluates the persistence file. It then re-registers
all debug targets found in the file, which will update or augment any
configurations already established (e.g., from `debrief-debug-vars`).
Finally, it re-applies the global debug settings.
If the persistence file does not exist, it logs an informational message
and does nothing further to the existing configurations.
Return:
  nil. Side effect is modifying Debrief's internal state and applying settings."
  (interactive)
  (if (not (file-exists-p debrief-persist-file))
      (debrief--log :info nil
                    "No Debrief persistence file found at %s. Skipping load."
                    debrief-persist-file)
    (debrief--log :info nil "Loading Debrief configuration from %s..."
                  debrief-persist-file)
    (condition-case err
        (progn
          ;; Do NOT clear `debrief--debug-config`, `debrief--debug-groups`,
          ;; or `debrief--original-values` here. We want the loaded state
          ;; to overlay the defaults from `debrief-debug-vars`.

          ;; These are reset because the persist file will explicitly set them if saved.
          (setq debrief--active-monitored-hooks nil)
          (setq debrief--global-hook-monitor-advice-active-p nil)
          ;; The `debrief--loaded-configs` var will be set by `load-file`.
          (setq debrief--loaded-configs nil)

          ;; Evaluate the saved file. This will set global variables like
          ;; `debrief-debug-enabled` and populate `debrief--loaded-configs`.
          (load-file debrief-persist-file)

          ;; Re-register debug targets from the loaded configurations.
          ;; `debrief--register-debug-target` will update existing entries in
          ;; `debrief--debug-config` or add new ones.
          (when debrief--loaded-configs
            (debrief--log :debug nil "Registering %d debug targets from saved state."
                          (length debrief--loaded-configs))
            (dolist (entry-plist debrief--loaded-configs)
              (if (plistp entry-plist) ; Ensure entry is a valid plist
                  ;; Sanitize again, as persisted format might differ slightly or
                  ;; to catch any manual edits to persist file.
                  (let ((sanitized-entry (debrief--sanitize-entry-plist entry-plist)))
                    (when-let ((target (plist-get sanitized-entry :target)))
                      ;; Register without saving state again during this batch load.
                      (debrief--register-debug-target target sanitized-entry nil)))
                (debrief--log :error nil
                              "Corrupted entry in loaded configs: Expected plist, got %S. Skipping."
                              entry-plist)))
            ;; Clear the temporary variable after processing.
            (setq debrief--loaded-configs nil))

          ;; Re-apply global debug state and refresh all targets based on loaded settings.
          ;; `debrief-update-debug-vars` will handle applying configs to all targets
          ;; using the `debrief-debug-enabled` value loaded from the persist file.
          (debrief-update-debug-vars debrief-debug-enabled)
          (debrief--log :info nil "Debrief configuration loaded successfully from %s."
                        debrief-persist-file))
      (error
       (debrief--log :error nil "Failed to load Debrief configuration from %s: %S"
                     debrief-persist-file err)
       (message "Debrief: Error loading state from %s. See *Messages*."
                debrief-persist-file))))
  nil)

;;;###autoload
(defun debrief/reset-all ()
  "Reset all Debrief configurations to their default states.
This function performs a comprehensive reset:
- Deactivates all currently active debug targets (removing advice, watchers).
- Clears all internal Debrief data structures (configurations, groups, etc.).
- Resets Debrief-specific custom variables to their `defcustom` default values.
- Re-initializes targets based on the default `debrief-debug-vars`.
- Deletes the Debrief persistence file (`debrief-persist-file`), if it exists.
This is useful for starting with a clean Debrief slate or recovering from
a potentially corrupted or problematic configuration.
A restart of Emacs might be advisable after a full reset if unexpected
behavior persists, though Debrief attempts to clean up thoroughly.
Return:
  nil. Extensive side effects on Debrief's state and the persistence file."
  (interactive)
  (debrief--log :warn nil "Resetting all Debrief configurations to defaults...")

  ;; 1. Deactivate all currently active targets to ensure proper cleanup
  ;;    (e.g., advice removed, watchers detached).
  ;;    Iterate over a copy of keys as deactivation might modify `debrief--debug-config`.
  (let ((current-targets (ht-keys debrief--debug-config)))
    (--each current-targets
      (lambda (target-sym)
        (when-let ((entry-plist (ht-get debrief--debug-config target-sym)))
          ;; To deactivate, we effectively tell `debrief-apply-entry-config`
          ;; that the entry is no longer active by simulating a disabled state.
          (let ((debrief-debug-enabled nil)) ; Temporarily disable for this call
            (debrief-apply-entry-config entry-plist))))))

  ;; 2. Clear internal Debrief data structures.
  (ht-clear! debrief--debug-config)
  (ht-clear! debrief--debug-groups)
  (clrhash debrief--original-values) ; `clrhash` for hash-table.el compatibility
  (setq debrief--active-monitored-hooks nil)
  (setq debrief--global-hook-monitor-advice-active-p nil)
  ;; Ensure global hook advice is physically removed if it was active.
  (when (fboundp 'debrief--ensure-global-hook-advice)
    (debrief--ensure-global-hook-advice nil))


  ;; 3. Reset Debrief's custom variables to their `defcustom` default values.
  ;;    The `nil t` arguments to `custom-set-variables` achieve this.
  (custom-set-variables
   '(debrief-debug-enabled nil nil t) ; Reset to nil, mark as default
   '(debrief-log-destination :messages nil t)
   '(debrief-log-dedicated-buffer-name "*Debrief Log*" nil t)
   '(debrief-log-file-path (locate-user-emacs-file "debrief-log.log") nil t)
   '(debrief-log-level-threshold 'debug nil t)
   '(debrief-hook-monitor-enabled t nil t))
  ;; After resetting, explicitly call the setter for debrief-debug-enabled
  ;; to ensure its logic (like calling debrief-update-debug-vars) runs.
  (setq debrief-debug-enabled nil)

  ;; 4. Re-initialize targets from the default `debrief-debug-vars` (from `debrief-core.el`).
  ;;    This will populate `debrief--debug-config` with defaults, but they will be
  ;;    inactive due to `debrief-debug-enabled` being nil.
  (when (fboundp 'debrief--initialize-targets-from-custom-vars)
    (debrief--initialize-targets-from-custom-vars))

  ;; 5. Delete the persistence file if it exists.
  (when (file-exists-p debrief-persist-file)
    (condition-case err
        (delete-file debrief-persist-file)
      (error (debrief--log :error nil "Failed to delete persistence file %s: %S"
                           debrief-persist-file err)))
    (debrief--log :info nil "Deleted Debrief persistence file: %s"
                  debrief-persist-file))

  (debrief--log :info nil
                "Debrief configurations reset to defaults. Restart Emacs if issues persist.")
  (message "Debrief configurations reset to defaults. Restart Emacs if issues persist."))

(provide 'debrief-persist)
;;; debrief-persist.el ends here