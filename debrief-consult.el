;;; debrief-consult.el --- Consult integration for Debrief -*- lexical-binding: t; -*-
;;
;;; Commentary:
;;
;; This module provides integration with the `consult.el` package, enabling
;; users to interact with Debrief's debugging targets through Consult's
;; powerful selection UIs.
;;
;; Key functionalities include:
;; - A Consult source (`debrief/consult-targets`) for listing and selecting
;;   registered Debrief targets.
;; - Formatting of candidates to show their status (active/inactive) and type.
;; - Rich annotations for each target using `marginalia.el`, displaying
;;   details like group, log level, watch status, etc.
;; - A set of actions available for each selected target, allowing users to
;;   toggle, unregister, or perform other target-specific operations directly
;;   from the Consult interface.
;; - Candidates are presented as strings with the actual target symbol attached
;;   as a text property (`:debrief-target-symbol`), which is then used by
;;   action and annotation functions.

;;; Code:

(require 'consult)
(require 'dash)             ; For utility functions like --map
(require 's)                ; For string manipulation (s-truncate, s-blank?)
(require 'marginalia)       ; For rich annotations in Consult
(require 'subr-x)           ; For if-let, when-let
(require 'debrief-core)     ; For core Debrief variables and functions
(require 'debrief-commands) ; For commands to act on targets
(require 'debrief-log)      ; For debrief--log (though mostly for internal logging here)
(require 'debrief-ui)

(defvar debrief-consult-history nil
  "History list for the `debrief/consult-targets` command.")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                        Consult Candidate Helpers                           ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun debrief--consult-target-candidates-raw ()
  "Return all registered Debrief debug targets as a list of symbols.
This function retrieves the keys (target symbols) from the central
`debrief--debug-config` hash table.
Return:
  (list symbol): A list of all currently registered target symbols."
  (let ((candidates (ht-keys debrief--debug-config)))
    (debrief--log :debug nil
                  "[Consult] Raw target candidates retrieved: %S" candidates)
    candidates))

(defun debrief--consult-format-candidate-string (sym)
  "Return a formatted display string for debug target SYM.
The returned string includes an active status indicator (✓/✗) and the
symbol name. The original SYM is attached as a text property
`:debrief-target-symbol` to the string.
Arguments:
  SYM (symbol): The debug target symbol to format.
Return:
  (string): A propertized string suitable for display in Consult, or a
            plain string indicating an invalid candidate if SYM is not a symbol."
  (debrief--log :trace sym "[Consult] Formatting candidate string for: %S" sym)
  (if (not (symbolp sym))
      (progn
        (debrief--log :warn sym "[Consult] Non-symbol passed for formatting: %S" sym)
        (format "Invalid-Candidate: %S" sym))
    (let* ((config (ht-get debrief--debug-config sym))
           (active? (debrief--is-entry-active-p config))
           (base-string (format "%s %s"
                                (if active? (propertize "✓" 'face 'success)
                                  (propertize "✗" 'face 'error))
                                (propertize (symbol-name sym)
                                            'face 'font-lock-variable-name-face)))
           ;; Attach the original symbol as metadata for later retrieval
           (propertized-string (propertize base-string :debrief-target-symbol sym)))
      (debrief--log :trace sym "[Consult] Formatted string for %S: %S (props: %S)"
                    sym propertized-string
                    (text-properties-at 0 propertized-string))
      propertized-string)))

(defun debrief--consult-items-function ()
  "Return a list of propertized display strings for all Debrief targets.
Each string in the list is formatted by `debrief--consult-format-candidate-string`
and includes the original target symbol as a text property. This list is
used as the collection of candidates for `consult--read`.
Return:
  (list string): A list of propertized strings, one for each debug target."
  (let* ((raw-candidates (debrief--consult-target-candidates-raw))
         (items (--map (debrief--consult-format-candidate-string it)
                       raw-candidates)))
    (debrief--log :debug nil "[Consult] Generated %d display items for Consult."
                  (length items))
    items))

(defun debrief--consult-marginalia (candidate-item)
  "Return an annotation string for CANDIDATE-ITEM for display by Marginalia.
CANDIDATE-ITEM is typically the propertized string generated by
`debrief--consult-format-candidate-string`. This function extracts the
target symbol from the text property and formats a rich annotation string
showing various details about the target's configuration.
Arguments:
  CANDIDATE-ITEM (string|symbol|cons): The candidate item. Expected to be a
    string with a `:debrief-target-symbol` property. Handles other forms
    as fallbacks for robustness with Marginalia's calling conventions.
Return:
  (string): A formatted annotation string, or an empty string if the
            candidate is invalid or no symbol can be extracted."
  (cl-block debrief--consult-marginalia
    (let ((candidate-symbol nil))
      ;; Robustly determine the actual symbol from the candidate item
      (cond
       ((stringp candidate-item)
        (setq candidate-symbol (get-text-property 0 :debrief-target-symbol
                                                  candidate-item)))
       ((symbolp candidate-item) ; Fallback if Marginalia calls with a raw symbol
        (setq candidate-symbol candidate-item))
       ((consp candidate-item)   ; Fallback for old (display . actual) format
        (debrief--log :warn nil
                      "[Consult] Marginalia called with unexpected cons cell: %S"
                      candidate-item)
        (setq candidate-symbol (cdr candidate-item))))

      (debrief--log :trace candidate-symbol
                    "[Consult] Marginalia processing symbol: %S (from item: %S)"
                    candidate-symbol candidate-item)

      (unless (symbolp candidate-symbol)
        (debrief--log :warn nil
                      "[Consult] Marginalia: Could not extract symbol from: %S"
                      candidate-item)
        (cl-return-from debrief--consult-marginalia "")) ; Return empty if no symbol

      ;; Fetch config and format details for annotation
      (let* ((cfg (ht-get debrief--debug-config candidate-symbol))
             (type (debrief--determine-target-type candidate-symbol cfg))
             (type-str (pcase type
                         (:hook-monitor "HookMon")
                         (:function-advice "Func")
                         (:variable "Var")
                         (_ "Unk")))
             (group-name (symbol-name (or (plist-get cfg :group) 'none)))
             (status-str (if (debrief--is-entry-active-p cfg)
                             (propertize "Active" 'face 'success)
                           (propertize "Inactive" 'face 'warning)))
             (minlog-val (plist-get cfg :min-log-level))
             (minlog-str (if minlog-val (symbol-name minlog-val) ""))
             (watch-val (plist-get cfg :watch))
             (watch-str (if watch-val (propertize "Watch" 'face 'success) ""))
             (break-val (plist-get cfg :break-on-change))
             (break-str (if break-val (propertize "Break" 'face 'error) ""))
             (timing-val (plist-get cfg :timing))
             (timing-str (if timing-val (propertize "Timing" 'face 'font-lock-keyword-face) ""))
             (val-str (if (and (eq type :variable) (boundp candidate-symbol))
                        (s-truncate 20 (format "%S" (symbol-value candidate-symbol)))
                      ""))
             (desc-val (plist-get cfg :description))
             (desc-str (if (not (s-blank? desc-val)) (s-truncate 40 desc-val) "")))

        (marginalia--fields
         (type-str :width 8 :face 'font-lock-type-face)
         (group-name :width 8 :face 'font-lock-constant-face)
         (status-str :width 8)
         (minlog-str :width 8 :face 'font-lock-preprocessor-face)
         (watch-str :width 6)
         (break-str :width 6)
         (timing-str :width 7)
         (val-str :width 8)
         (desc-str :width 0 :face 'font-lock-doc-face) ; Width 0 means take rest
         )))))

(defun debrief--consult-target-actions (sym)
  "Return a list of available actions for the debug target SYM.
Each action is a cons cell `(LABEL . FUNCTION)`, where LABEL is a string
describing the action, and FUNCTION is a zero-argument lambda that performs it.
The list of actions depends on the type and current configuration of SYM.
Arguments:
  SYM (symbol): The debug target symbol.
Return:
  (list (cons string function)): A list of action pairs."
  (let* ((cfg (ht-get debrief--debug-config sym))
         (type (debrief--determine-target-type sym cfg))
         (enabled-raw (plist-get cfg :enabled))
         ;; Evaluate :enabled if it's a function, otherwise use its boolean value
         (enabled? (if (functionp enabled-raw)
                       (let ((debrief--in-advised-call t)) (funcall enabled-raw))
                     enabled-raw))
         (arg-filter? (plist-get cfg :arg-filter))
         (ret-filter? (plist-get cfg :return-filter)))
    ;; Filter out nil entries (from conditional `when` clauses)
    (--filter it
              (list
               (cons (format "Toggle target (currently %s)" (if enabled? "ON" "OFF"))
                     (lambda () (debrief/toggle-target sym)))
               (cons "Unregister target"
                     (lambda () (debrief/unregister-target sym)))
               ;; Variable-specific actions
               (when (eq type :variable)
                 (cons (format "%s watching" (if (plist-get cfg :watch) "Stop" "Start"))
                       (lambda () (debrief/toggle-target-watch sym))))
               (when (eq type :variable)
                 (cons (format "%s break-on-change"
                               (if (plist-get cfg :break-on-change) "Stop" "Start"))
                       (lambda () (debrief/toggle-target-break-on-change sym))))
               ;; Function advice-specific actions
               (when (eq type :function-advice)
                 (cons "Call with temporary debug wrapper"
                       (lambda () (debrief/call-function-temporarily sym))))
               (when (eq type :function-advice)
                 (cons "Wrap function temporarily"
                       (lambda () (debrief/wrap-function-temporarily sym))))
               (when (eq type :function-advice)
                 (cons (format "%s arg filter" (if arg-filter? "Remove" "Add"))
                       (lambda () (if arg-filter?
                                      (debrief/remove-arg-filter sym)
                                    (debrief/add-arg-filter sym)))))
               (when (eq type :function-advice)
                 (cons (format "%s return filter" (if ret-filter? "Remove" "Add"))
                       (lambda () (if ret-filter?
                                      (debrief/remove-return-filter sym)
                                    (debrief/add-return-filter sym)))))
               ))))

(defun debrief--consult-perform-action (selected-candidate-string)
  "Prompt the user to choose an action for the SELECTED-CANDIDATE-STRING and execute it.
SELECTED-CANDIDATE-STRING is the string returned by `consult--read`, which should
have the target symbol attached as a `:debrief-target-symbol` text property.
This function retrieves the symbol, generates a list of applicable actions,
prompts the user to select one, and then executes the chosen action.
Arguments:
  SELECTED-CANDIDATE-STRING (string): The candidate string selected by the user.
Return:
  nil. Actions are performed as side effects."
  (cl-block debrief--consult-perform-action
    (debrief--log :debug nil "[Consult] Performing action for selected string: %S"
                  selected-candidate-string)

    (unless (stringp selected-candidate-string)
      (debrief--log :error nil "[Consult] Action: Expected a string candidate, got: %S"
                    selected-candidate-string)
      (user-error "Cannot perform action, invalid candidate format: %S"
                  selected-candidate-string)
      (cl-return-from debrief--consult-perform-action nil))

    ;; Extract the target symbol from the text property
    (let ((sym (get-text-property 0 :debrief-target-symbol selected-candidate-string)))
      (unless (symbolp sym)
        (debrief--log :error nil
                      "[Consult] Action: Could not extract :debrief-target-symbol from: %S"
                      selected-candidate-string)
        (user-error "Cannot perform action, candidate missing symbol metadata: %S"
                    selected-candidate-string)
        (cl-return-from debrief--consult-perform-action nil))

      (debrief--log :debug sym "[Consult] Actions for symbol: %S (from string)" sym)
      (let* ((actions (debrief--consult-target-actions sym))
             (choice (completing-read (format "Action for %s: " sym)
                                      (--map (car it) actions) ; Present action labels
                                      nil t))) ; Require match, no initial input
        (debrief--log :debug sym "[Consult] User chose action '%s' for %S" choice sym)
        (if-let ((action-pair (assoc choice actions #'equal)))
            (let ((action-fn (cdr action-pair)))
              (debrief--log :debug sym "[Consult] Executing action '%s' for %S"
                            choice sym)
              (funcall action-fn)
              ;; Refresh the Debrief targets list UI if it's open and relevant
              (when (and (fboundp 'debrief/list-registered-targets)
                         (get-buffer debrief-list-registered-buffer-name))
                (with-current-buffer (get-buffer debrief-list-registered-buffer-name)
                  (if (derived-mode-p 'debrief-targets-list-mode)
                      (debrief/list-registered-targets)))))
          (debrief--log :warn sym "[Consult] No action found for choice '%s' on target %S"
                        choice sym))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;                            Consult Entry Point                             ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;###autoload
(defun debrief/consult-targets ()
  "Prompt for a Debrief target using Consult and then offer actions for it.
This command uses `consult--read` to allow the user to select a Debrief target
from a list. Once a target is selected, `debrief--consult-perform-action`
is called to let the user choose and execute an action on that target.
Return:
  nil. Actions are performed as side effects."
  (interactive)
  (debrief--log :debug nil "[Consult] `debrief/consult-targets` invoked.")
  (let ((candidates (debrief--consult-items-function)) ; Get list of propertized strings
        (selected-candidate nil))
    ;; Use consult--read to select a candidate string
    (setq selected-candidate
          (consult--read
           candidates                               ; The list of candidate strings
           :prompt "Debrief Target: "
           :category 'debrief-target                ; For Marginalia and other integrations
           :annotate 'debrief--consult-marginalia   ; Function for annotations
           :history 'debrief-consult-history        ; History variable symbol
           :require-match t                         ; Must select an existing candidate
           :sort t                                  ; Sort candidates alphabetically
           ))

    ;; If a candidate was selected, proceed to perform an action on it
    (if selected-candidate
        (progn
          (debrief--log :debug nil
                        "[Consult] Candidate selected: %S. Performing action."
                        selected-candidate)
          (debrief--consult-perform-action selected-candidate))
      (debrief--log :debug nil
                    "[Consult] No candidate selected or selection aborted."))))

;; Register the annotator function with Marginalia.
;; This tells Marginalia how to generate annotations for candidates of
;; category `debrief-target`.
(eval-after-load 'marginalia
  '(add-to-list 'marginalia-annotator-registry
                '(debrief-target debrief--consult-marginalia builtin nil)))

(provide 'debrief-consult)
;;; debrief-consult.el ends here